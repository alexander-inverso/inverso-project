<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ALEXANDER // THINK 4D</title>
    <!-- Cargamos fuentes con mucha personalidad -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;500;700&family=Syne:wght@400;700;800&display=swap" rel="stylesheet">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* El scroll lo maneja el canvas */
            background-color: #ffffff;
            cursor: default; /* Cursor base */
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>

    <canvas id="app"></canvas>

    <script>
        /**
         * ALEXANDER ENGINE v1.0
         * Motor de renderizado UI basado puramente en Canvas API.
         * Sin DOM elements. Pura geometr√≠a y tipograf√≠a.
         */

        const canvas = document.getElementById('app');
        const ctx = canvas.getContext('2d', { alpha: false }); // Optimizaci√≥n

        // --- CONFIGURACI√ìN DE ESTILO ---
        const PALETTE = {
            bg: '#ffffff',
            ink: '#111111',
            accent: '#ff4e00', // Safety Orange
            accentLight: '#fff0e6',
            gray: '#eeeeee'
        };

        const FONTS = {
            display: '800 {s}px "Syne"',
            body: '500 {s}px "Space Grotesk"',
            mono: '400 {s}px "Courier New"'
        };

        // --- ESTADO DEL SISTEMA ---
        let STATE = {
            width: window.innerWidth,
            height: window.innerHeight,
            page: 'HOME', // HOME, ESSAYS, IDENTITY, FUNDING
            scrollY: 0,
            targetScrollY: 0,
            maxScroll: 0,
            mouseX: 0,
            mouseY: 0,
            cursor: 'default',
            shapes: [] // Geometr√≠a de fondo
        };

        // Zonas activas (botones, links) del frame actual
        let clickables = [];

        // --- 1. INICIALIZACI√ìN Y EVENTOS ---

        function resize() {
            // Manejo de DPI para nitidez en pantallas retina
            const dpr = window.devicePixelRatio || 1;
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            ctx.scale(dpr, dpr);
            STATE.width = window.innerWidth;
            STATE.height = window.innerHeight;
            
            // Regenerar fondo geom√©trico al redimensionar
            initShapes();
        }

        window.addEventListener('resize', resize);
        
        // Scroll Virtual
        window.addEventListener('wheel', (e) => {
            STATE.targetScrollY += e.deltaY;
            // Limites del scroll
            if (STATE.targetScrollY < 0) STATE.targetScrollY = 0;
            if (STATE.targetScrollY > STATE.maxScroll) STATE.targetScrollY = STATE.maxScroll;
        });

        // Mouse Tracker
        window.addEventListener('mousemove', (e) => {
            STATE.mouseX = e.clientX;
            STATE.mouseY = e.clientY;
            
            // Detecci√≥n de Hover
            let hovering = false;
            // Ajustamos Y por si hay elementos fijos vs scrolleables
            for (let btn of clickables) {
                if (hitTest(btn)) {
                    hovering = true;
                    break;
                }
            }
            document.body.style.cursor = hovering ? 'pointer' : 'default';
        });

        // Click Handler
        window.addEventListener('click', (e) => {
            for (let btn of clickables) {
                if (hitTest(btn)) {
                    btn.action();
                    break;
                }
            }
        });

        // Generador de Geometr√≠a "Canva-like"
        function initShapes() {
            STATE.shapes = [];
            for(let i=0; i<15; i++) {
                STATE.shapes.push({
                    x: Math.random() * STATE.width,
                    y: Math.random() * STATE.height * 2, // Esparcido en vertical
                    size: 50 + Math.random() * 300,
                    type: Math.random() > 0.5 ? 'circle' : 'rect',
                    color: Math.random() > 0.6 ? PALETTE.accent : '#000000',
                    alpha: 0.03 + Math.random() * 0.05,
                    rotation: Math.random() * Math.PI
                });
            }
        }

        // --- 2. MOTOR DE DIBUJO (CORE) ---

        function draw() {
            // A. Limpieza
            ctx.fillStyle = PALETTE.bg;
            ctx.fillRect(0, 0, STATE.width, STATE.height);

            // B. F√≠sica del Scroll (Lerp para suavidad)
            STATE.scrollY += (STATE.targetScrollY - STATE.scrollY) * 0.1;

            // C. Fondo Geom√©trico (Parallax sutil)
            ctx.save();
            ctx.translate(0, -STATE.scrollY * 0.5); // Se mueve m√°s lento
            drawBackgroundShapes();
            ctx.restore();

            // D. Reiniciar zonas clickables del frame
            clickables = [];

            // E. Renderizado de P√°gina (Scrollable)
            ctx.save();
            ctx.translate(0, -STATE.scrollY);

            let contentHeight = 0;

            if (STATE.page === 'HOME') contentHeight = renderHome();
            else if (STATE.page === 'ESSAYS') contentHeight = renderEssays();
            else if (STATE.page === 'IDENTITY') contentHeight = renderIdentity();
            else if (STATE.page === 'FUNDING') contentHeight = renderFunding();

            STATE.maxScroll = Math.max(0, contentHeight - STATE.height + 100);
            ctx.restore();

            // F. Elementos Fijos (UI Flotante)
            renderMarquee();
            renderNav();

            requestAnimationFrame(draw);
        }

        // --- 3. COMPONENTES GR√ÅFICOS ---

        function drawBackgroundShapes() {
            STATE.shapes.forEach(s => {
                ctx.save();
                ctx.translate(s.x, s.y);
                ctx.rotate(s.rotation);
                ctx.globalAlpha = s.alpha;
                ctx.fillStyle = s.color;
                
                if (s.type === 'circle') {
                    ctx.beginPath();
                    ctx.arc(0, 0, s.size/2, 0, Math.PI*2);
                    ctx.fill();
                } else {
                    ctx.fillRect(-s.size/2, -s.size/2, s.size, s.size);
                }
                ctx.restore();
            });
        }

        function renderMarquee() {
            const text = "THINK 4D  ///  BE DIFFERENT, NOT INDIFFERENT  ///  DESIGN YOUR FUTURE  ///  TRANSPARENCY IS THE NEW SMART  ///  ";
            const fontSize = 16;
            ctx.font = FONTS.display.replace('{s}', fontSize);
            
            // Fondo Marquee
            ctx.fillStyle = PALETTE.accent;
            ctx.fillRect(0, 0, STATE.width, 30);
            
            // Texto en movimiento
            ctx.fillStyle = '#fff';
            const speed = Date.now() / 20;
            const textWidth = ctx.measureText(text).width;
            const offset = -(speed % textWidth);
            
            ctx.fillText(text + text, offset, 20); // Dibujamos doble para el loop
            
            // L√≠nea divisoria
            ctx.fillStyle = PALETTE.ink;
            ctx.fillRect(0, 30, STATE.width, 3);
        }

        function renderNav() {
            const y = 33;
            const h = 60;
            
            // Fondo Nav
            ctx.fillStyle = 'rgba(255,255,255,0.95)';
            ctx.fillRect(0, y, STATE.width, h);
            ctx.fillStyle = PALETTE.ink;
            ctx.fillRect(0, y+h, STATE.width, 4); // Borde inferior grueso

            // Logo
            ctx.fillStyle = PALETTE.ink;
            ctx.font = FONTS.display.replace('{s}', 28);
            ctx.fillText("ALEXANDER.", 20, y + 40);

            // Botones Men√∫
            const pages = [
                { id: 'HOME', label: 'COVER' },
                { id: 'ESSAYS', label: 'ENSAYOS' },
                { id: 'IDENTITY', label: 'WHO AM I' },
                { id: 'FUNDING', label: 'GOAL: LIYSF' }
            ];

            let xPos = STATE.width - 20;
            
            // Dibujar de derecha a izquierda
            // Invertimos array temporalmente para c√°lculo layout
            [...pages].reverse().forEach(page => {
                ctx.font = FONTS.body.replace('{s}', 14);
                const labelW = ctx.measureText(page.label).width + 40;
                xPos -= labelW;

                const isActive = STATE.page === page.id;
                const btnRect = { x: xPos, y: y + 15, w: labelW - 10, h: 30, fixed: true };

                // Detecci√≥n hover visual (solo pinta, la l√≥gica est√° en loop principal)
                const isHover = hitTest(btnRect);

                // Estilo Bot√≥n
                if (isActive || isHover) {
                    ctx.fillStyle = isActive ? PALETTE.ink : '#ddd';
                    ctx.fillRect(btnRect.x, btnRect.y, btnRect.w, btnRect.h);
                    ctx.fillStyle = isActive ? '#fff' : PALETTE.ink;
                } else {
                    ctx.fillStyle = PALETTE.ink;
                }

                ctx.fillText(page.label, btnRect.x + 15, btnRect.y + 20);

                // Registrar zona click
                clickables.push({
                    ...btnRect,
                    action: () => { STATE.page = page.id; STATE.targetScrollY = 0; }
                });
            });
        }

        // --- 4. RENDERIZADO DE P√ÅGINAS (CONTENIDO) ---

        function renderHome() {
            let cursorY = 200;

            // TITULAR GIGANTE
            const bigSize = Math.min(150, STATE.width * 0.15);
            ctx.fillStyle = PALETTE.ink;
            ctx.font = FONTS.display.replace('{s}', bigSize);
            ctx.textAlign = 'left';
            
            ctx.fillText("THINK", 50, cursorY);
            cursorY += bigSize * 0.9;
            
            // "4D" con gradiente/color
            ctx.fillStyle = PALETTE.accent;
            ctx.fillText("4D.", 50, cursorY);
            
            // Stroke effect (simulado dibujando offset negro detr√°s, o strokeText)
            ctx.lineWidth = 3;
            ctx.strokeStyle = PALETTE.ink;
            ctx.strokeText("4D.", 50, cursorY);

            cursorY += 50;

            // INTRODUCCI√ìN
            const text = "No soy m√©dico. Soy un arquitecto de sistemas biol√≥gicos en formaci√≥n. Bienvenido a mi repositorio p√∫blico.";
            wrapText(text, 70, cursorY, Math.min(500, STATE.width - 100), 24, FONTS.body);

            // STICKER DECORATIVO (Rotado)
            ctx.save();
            const stickerX = STATE.width * 0.7;
            const stickerY = 300;
            if (STATE.width > 800) {
                ctx.translate(stickerX, stickerY);
                ctx.rotate(10 * Math.PI / 180);
                
                // Sombra dura
                ctx.fillStyle = PALETTE.ink;
                ctx.fillRect(10, 10, 250, 150);
                // Caja blanca
                ctx.fillStyle = '#fff';
                ctx.lineWidth = 4;
                ctx.strokeStyle = PALETTE.ink;
                ctx.fillRect(0, 0, 250, 150);
                ctx.strokeRect(0, 0, 250, 150);
                
                // Texto Sticker
                ctx.fillStyle = PALETTE.ink;
                ctx.font = FONTS.display.replace('{s}', 40);
                ctx.fillText("96%", 20, 60);
                ctx.font = FONTS.body.replace('{s}', 14);
                ctx.fillText("TARGET EBAU", 20, 90);
                ctx.fillStyle = PALETTE.accent;
                ctx.fillText("ESTIMADO", 20, 110);
            }
            ctx.restore();

            return STATE.height; // Home no necesita mucho scroll
        }

        function renderEssays() {
            let cursorY = 180;
            
            // T√çTULO
            ctx.fillStyle = PALETTE.ink;
            ctx.font = FONTS.display.replace('{s}', 60);
            ctx.fillText("ENSAYOS.", 50, cursorY);
            cursorY += 80;

            // GRID DE ART√çCULOS
            const articles = [
                { title: "La Muerte como Fallo de Software", tag: "#BIO-SYSTEMS", status: "REVISADO", date: "02 ENE 2026" },
                { title: "Ingenier√≠a Inversa del 10", tag: "#MATEM√ÅTICAS", status: "BORRADOR", date: "PENDIENTE" },
                { title: "One Take: Transparencia Radical", tag: "#MANIFIESTO", status: "PR√ìXIMAMENTE", date: "2026" }
            ];

            const cols = STATE.width > 900 ? 3 : 1;
            const cardW = (STATE.width - 100 - (20 * (cols-1))) / cols;
            const cardH = 300;

            articles.forEach((art, i) => {
                const col = i % cols;
                const row = Math.floor(i / cols);
                const x = 50 + col * (cardW + 20);
                const y = cursorY + row * (cardH + 20);

                // Caja Brutalista
                const isHover = hitTest({x, y: y - STATE.scrollY, w: cardW, h: cardH, fixed: false}); // Fix scroll check
                
                // Sombra
                ctx.fillStyle = isHover ? PALETTE.accent : PALETTE.ink;
                ctx.fillRect(x + 8, y + 8, cardW, cardH);

                // Fondo
                ctx.fillStyle = i === 2 ? PALETTE.ink : '#fff'; // El tercero es negro
                ctx.fillRect(x, y, cardW, cardH);
                ctx.lineWidth = 3;
                ctx.strokeStyle = i === 2 ? '#fff' : PALETTE.ink;
                ctx.strokeRect(x, y, cardW, cardH);

                // Texto
                ctx.fillStyle = i === 2 ? '#fff' : PALETTE.ink;
                
                // Tag
                ctx.font = FONTS.mono.replace('{s}', 12);
                ctx.fillText(art.tag, x + 20, y + 30);
                
                // Status Badge
                ctx.save();
                ctx.translate(x + cardW - 10, y + 10);
                ctx.rotate(5 * Math.PI / 180);
                ctx.fillStyle = PALETTE.accent;
                ctx.fillRect(-80, 0, 80, 20);
                ctx.fillStyle = '#fff';
                ctx.font = "bold 10px Arial";
                ctx.fillText(art.status, -75, 14);
                ctx.restore();

                // T√≠tulo (Wrap manual simple)
                ctx.fillStyle = i === 2 ? '#fff' : PALETTE.ink;
                wrapText(art.title, x + 20, y + 80, cardW - 40, 30, FONTS.display);

                // Bot√≥n Fake Leer
                ctx.font = FONTS.body.replace('{s}', 14);
                ctx.fillText("LEER ART√çCULO ->", x + 20, y + cardH - 20);

                // Bot√≥n real funcionalidad (imprimir poster de este art√≠culo)
                clickables.push({
                    x, y, w: cardW, h: cardH, fixed: false,
                    action: () => alert(`Abriendo: ${art.title}`)
                });
            });

            return cursorY + Math.ceil(articles.length/cols) * (cardH + 20) + 100;
        }

        function renderIdentity() {
            let cursorY = 180;
            ctx.fillStyle = PALETTE.ink;
            
            // WHO AM I
            ctx.font = FONTS.display.replace('{s}', 100);
            ctx.fillText("WHO", 50, cursorY);
            cursorY += 90;
            ctx.fillText("AM I?", 50, cursorY);
            cursorY += 80;

            // Bloque de Texto
            const text = "No encajo en el molde. Mientras otros memorizan para el examen, yo intento entender el c√≥digo fuente del cuerpo humano. Tengo 17 a√±os. Mi objetivo no es un t√≠tulo, es una caja de herramientas.";
            
            // Highlighter effect background
            const lines = wrapText(text, 50, cursorY, Math.min(600, STATE.width - 60), 24, FONTS.body, true); // true = dry run
            
            // Dibujar subrallado para cada l√≠nea
            ctx.fillStyle = PALETTE.accentLight;
            lines.forEach(line => {
                ctx.fillRect(50, cursorY + (line.index * 35) - 20, ctx.measureText(line.text).width, 30);
            });

            // Dibujar texto real
            ctx.fillStyle = PALETTE.ink;
            wrapText(text, 50, cursorY, Math.min(600, STATE.width - 60), 35, FONTS.body);

            cursorY += lines.length * 35 + 50;

            // Bloques de Atributos
            const attrs = [
                { l: "ORIGEN", v: "Outsider Competente" },
                { l: "DESTINO", v: "ETH Z√∫rich / UZH" },
                { l: "FILOSOF√çA", v: "Teardown everything" }
            ];

            attrs.forEach(a => {
                ctx.fillStyle = PALETTE.ink;
                ctx.fillRect(50, cursorY, 5, 50);
                
                ctx.font = FONTS.display.replace('{s}', 16);
                ctx.fillText(a.l, 70, cursorY + 15);
                
                ctx.font = FONTS.body.replace('{s}', 20);
                ctx.fillText(a.v, 70, cursorY + 40);
                
                cursorY += 70;
            });

            return cursorY + 100;
        }

        function renderFunding() {
            let cursorY = 180;
            
            ctx.fillStyle = PALETTE.ink;
            ctx.font = FONTS.display.replace('{s}', 50);
            ctx.fillText("THE NEXT STEP", 50, cursorY);
            cursorY += 60;

            // Caja LIYSF
            const boxW = Math.min(600, STATE.width - 60);
            const boxH = 150;
            
            // Sombra
            ctx.fillStyle = '#ccc';
            ctx.fillRect(58, cursorY + 8, boxW, boxH);
            // Caja
            ctx.fillStyle = '#fff';
            ctx.fillRect(50, cursorY, boxW, boxH);
            ctx.strokeStyle = PALETTE.ink;
            ctx.strokeRect(50, cursorY, boxW, boxH);

            // Contenido Caja
            ctx.fillStyle = PALETTE.ink;
            ctx.font = FONTS.display.replace('{s}', 24);
            ctx.fillText("LIYSF (LONDON)", 70, cursorY + 40);

            // Barra Progreso
            const barW = boxW - 40;
            const progress = 0.75; // 75%
            
            ctx.fillStyle = '#eee';
            ctx.fillRect(70, cursorY + 60, barW, 30);
            
            ctx.fillStyle = PALETTE.accent;
            ctx.fillRect(70, cursorY + 60, barW * progress, 30);
            
            // Patr√≥n rayado en la barra
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 2;
            for(let i=0; i<barW*progress; i+=10) {
                ctx.beginPath();
                ctx.moveTo(70 + i, cursorY + 90);
                ctx.lineTo(70 + i + 10, cursorY + 60);
                ctx.stroke();
            }

            ctx.fillStyle = PALETTE.ink;
            ctx.font = FONTS.mono.replace('{s}', 14);
            ctx.fillText("75% CONSEGUIDO", 70, cursorY + 110);

            // Bot√≥n Generar Poster (Funcionalidad Extra)
            const btnY = cursorY + 200;
            const btnW = 250;
            const btnH = 60;
            
            ctx.fillStyle = PALETTE.ink;
            ctx.fillRect(50, btnY, btnW, btnH);
            ctx.fillStyle = '#fff';
            ctx.font = FONTS.display.replace('{s}', 14);
            ctx.fillText("üñ®Ô∏è IMPRIMIR P√ÅGINA (P√ìSTER)", 70, btnY + 35);
            
            clickables.push({
                x: 50, y: btnY, w: btnW, h: btnH, fixed: false,
                action: () => {
                    // Hack para descargar el canvas como imagen
                    const link = document.createElement('a');
                    link.download = 'alexander_poster.png';
                    link.href = canvas.toDataURL();
                    link.click();
                }
            });

            return btnY + 200;
        }

        // --- UTILIDADES ---

        // Helper para texto multil√≠nea
        function wrapText(text, x, y, maxWidth, lineHeight, font, dryRun = false) {
            ctx.font = font.replace('{s}', lineHeight * 0.8); // Ajuste tama√±o vs linea
            const words = text.split(' ');
            let line = '';
            let lines = [];
            let currentY = y;
            let lineIndex = 0;

            for(let n = 0; n < words.length; n++) {
                const testLine = line + words[n] + ' ';
                const metrics = ctx.measureText(testLine);
                const testWidth = metrics.width;
                if (testWidth > maxWidth && n > 0) {
                    if (!dryRun) ctx.fillText(line, x, currentY);
                    lines.push({ text: line, index: lineIndex++ });
                    line = words[n] + ' ';
                    currentY += lineHeight;
                } else {
                    line = testLine;
                }
            }
            if (!dryRun) ctx.fillText(line, x, currentY);
            lines.push({ text: line, index: lineIndex++ });
            
            return dryRun ? lines : currentY;
        }

        // Detector de colisiones
        function hitTest(rect) {
            // Si es fixed (UI), usa coords directas. Si no, suma el scroll.
            const mouseY = rect.fixed ? STATE.mouseY : STATE.mouseY + STATE.scrollY;
            return (
                STATE.mouseX >= rect.x &&
                STATE.mouseX <= rect.x + rect.w &&
                mouseY >= rect.y &&
                mouseY <= rect.y + rect.h
            );
        }

        // --- ARRANQUE ---
        resize();
        initShapes();
        requestAnimationFrame(draw);

    </script>
</body>
</html>

